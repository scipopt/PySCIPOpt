from dataclasses import dataclass
from typing import ClassVar

import numpy
from _typeshed import Incomplete

CONST: Term
EventNames: dict
MAJOR: int
MINOR: int
Operator: Op
PATCH: int
PY_SCIP_CALL: Incomplete
StageNames: dict
_SCIP_BOUNDTYPE_TO_STRING: dict
_expr_richcmp: Incomplete
_is_number: Incomplete
_matrixexpr_richcmp: Incomplete
buildGenExprObj: Incomplete
cos: Incomplete
exp: Incomplete
expr_to_array: Incomplete
expr_to_nodes: Incomplete
is_memory_freed: Incomplete
log: Incomplete
print_memory_in_use: Incomplete
quickprod: Incomplete
quicksum: Incomplete
readStatistics: Incomplete
sin: Incomplete
sqrt: Incomplete
str_conversion: Incomplete
value_to_array: Incomplete

class Benders:
    model: Incomplete
    name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def benderscreatesub(self, *args, **kwargs): ...
    def bendersexit(self, *args, **kwargs): ...
    def bendersexitpre(self, *args, **kwargs): ...
    def bendersexitsol(self, *args, **kwargs): ...
    def bendersfree(self, *args, **kwargs): ...
    def bendersfreesub(self, *args, **kwargs): ...
    def bendersgetvar(self, *args, **kwargs): ...
    def bendersinit(self, *args, **kwargs): ...
    def bendersinitpre(self, *args, **kwargs): ...
    def bendersinitsol(self, *args, **kwargs): ...
    def benderspostsolve(self, *args, **kwargs): ...
    def benderspresubsolve(self, *args, **kwargs): ...
    def benderssolvesub(self, *args, **kwargs): ...
    def benderssolvesubconvex(self, *args, **kwargs): ...

class Benderscut:
    benders: Incomplete
    model: Incomplete
    name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def benderscutexec(self, *args, **kwargs): ...
    def benderscutexit(self, *args, **kwargs): ...
    def benderscutexitsol(self, *args, **kwargs): ...
    def benderscutfree(self, *args, **kwargs): ...
    def benderscutinit(self, *args, **kwargs): ...
    def benderscutinitsol(self, *args, **kwargs): ...

class BoundChange:
    def __init__(self, *args, **kwargs) -> None: ...
    def getBoundchgtype(self, *args, **kwargs): ...
    def getBoundtype(self, *args, **kwargs): ...
    def getNewBound(self, *args, **kwargs): ...
    def getVar(self, *args, **kwargs): ...
    def isRedundant(self, *args, **kwargs): ...

class Branchrule:
    model: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def branchexecext(self, *args, **kwargs): ...
    def branchexeclp(self, *args, **kwargs): ...
    def branchexecps(self, *args, **kwargs): ...
    def branchexit(self, *args, **kwargs): ...
    def branchexitsol(self, *args, **kwargs): ...
    def branchfree(self, *args, **kwargs): ...
    def branchinit(self, *args, **kwargs): ...
    def branchinitsol(self, *args, **kwargs): ...

class Column:
    data: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def getAge(self, *args, **kwargs): ...
    def getBasisStatus(self, *args, **kwargs): ...
    def getLPPos(self, *args, **kwargs): ...
    def getLb(self, *args, **kwargs): ...
    def getObjCoeff(self, *args, **kwargs): ...
    def getPrimsol(self, *args, **kwargs): ...
    def getUb(self, *args, **kwargs): ...
    def getVar(self, *args, **kwargs): ...
    def isIntegral(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class ColumnExact:
    data: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class Conshdlr:
    model: Incomplete
    name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def consactive(self, *args, **kwargs): ...
    def conscheck(self, *args, **kwargs): ...
    def conscopy(self, *args, **kwargs): ...
    def consdeactive(self, *args, **kwargs): ...
    def consdelete(self, *args, **kwargs): ...
    def consdelvars(self, *args, **kwargs): ...
    def consdisable(self, *args, **kwargs): ...
    def consenable(self, *args, **kwargs): ...
    def consenfolp(self, *args, **kwargs): ...
    def consenfops(self, *args, **kwargs): ...
    def consenforelax(self, *args, **kwargs): ...
    def consexit(self, *args, **kwargs): ...
    def consexitpre(self, *args, **kwargs): ...
    def consexitsol(self, *args, **kwargs): ...
    def consfree(self, *args, **kwargs): ...
    def consgetdivebdchgs(self, *args, **kwargs): ...
    def consgetnvars(self, *args, **kwargs): ...
    def consgetpermsymgraph(self, *args, **kwargs): ...
    def consgetsignedpermsymgraph(self, *args, **kwargs): ...
    def consgetvars(self, *args, **kwargs): ...
    def consinit(self, *args, **kwargs): ...
    def consinitlp(self, *args, **kwargs): ...
    def consinitpre(self, *args, **kwargs): ...
    def consinitsol(self, *args, **kwargs): ...
    def conslock(self, *args, **kwargs): ...
    def consparse(self, *args, **kwargs): ...
    def conspresol(self, *args, **kwargs): ...
    def consprint(self, *args, **kwargs): ...
    def consprop(self, *args, **kwargs): ...
    def consresprop(self, *args, **kwargs): ...
    def conssepalp(self, *args, **kwargs): ...
    def conssepasol(self, *args, **kwargs): ...
    def constrans(self, *args, **kwargs): ...

class Constant(GenExpr):
    number: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class Constraint:
    data: Incomplete
    name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def getConshdlrName(self, *args, **kwargs): ...
    def isActive(self, *args, **kwargs): ...
    def isChecked(self, *args, **kwargs): ...
    def isDynamic(self, *args, **kwargs): ...
    def isEnforced(self, *args, **kwargs): ...
    def isInitial(self, *args, **kwargs): ...
    def isKnapsack(self, *args, **kwargs): ...
    def isLinear(self, *args, **kwargs): ...
    def isLinearType(self, *args, **kwargs): ...
    def isLocal(self, *args, **kwargs): ...
    def isModifiable(self, *args, **kwargs): ...
    def isNonlinear(self, *args, **kwargs): ...
    def isOriginal(self, *args, **kwargs): ...
    def isPropagated(self, *args, **kwargs): ...
    def isRemovable(self, *args, **kwargs): ...
    def isSeparated(self, *args, **kwargs): ...
    def isStickingAtNode(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Cutsel:
    model: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def cutselexit(self, *args, **kwargs): ...
    def cutselexitsol(self, *args, **kwargs): ...
    def cutselfree(self, *args, **kwargs): ...
    def cutselinit(self, *args, **kwargs): ...
    def cutselinitsol(self, *args, **kwargs): ...
    def cutselselect(self, *args, **kwargs): ...

class DomainChanges:
    def __init__(self, *args, **kwargs) -> None: ...
    def getBoundchgs(self, *args, **kwargs): ...

class Event:
    data: Incomplete
    name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def _getEventNames(self, *args, **kwargs): ...
    def getName(self, *args, **kwargs): ...
    def getNewBound(self, *args, **kwargs): ...
    def getNode(self, *args, **kwargs): ...
    def getOldBound(self, *args, **kwargs): ...
    def getRow(self, *args, **kwargs): ...
    def getType(self, *args, **kwargs): ...
    def getVar(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Eventhdlr:
    model: Incomplete
    name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def eventcopy(self, *args, **kwargs): ...
    def eventdelete(self, *args, **kwargs): ...
    def eventexec(self, *args, **kwargs): ...
    def eventexit(self, *args, **kwargs): ...
    def eventexitsol(self, *args, **kwargs): ...
    def eventfree(self, *args, **kwargs): ...
    def eventinit(self, *args, **kwargs): ...
    def eventinitsol(self, *args, **kwargs): ...

class Expr:
    terms: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def degree(self, *args, **kwargs): ...
    def normalize(self, *args, **kwargs): ...
    def __abs__(self): ...
    def __add__(self, other): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index): ...
    def __gt__(self, other: object) -> bool: ...
    def __iadd__(self, other): ...
    def __iter__(self): ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __mul__(self, other): ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self): ...
    def __next__(self): ...
    def __pow__(self, other): ...
    def __radd__(self, other): ...
    def __rmul__(self, other): ...
    def __rpow__(self, other): ...
    def __rsub__(self, other): ...
    def __rtruediv__(self, other): ...
    def __sub__(self, other): ...
    def __truediv__(self, other): ...

class ExprCons:
    _lhs: Incomplete
    _rhs: Incomplete
    expr: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def normalize(self, *args, **kwargs): ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class GenExpr:
    _op: Incomplete
    children: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def degree(self, *args, **kwargs): ...
    def getOp(self, *args, **kwargs): ...
    def __abs__(self): ...
    def __add__(self, other): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __mul__(self, other): ...
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self): ...
    def __pow__(self, other): ...
    def __radd__(self, other): ...
    def __rmul__(self, other): ...
    def __rpow__(self, other): ...
    def __rsub__(self, other): ...
    def __rtruediv__(self, other): ...
    def __sub__(self, other): ...
    def __truediv__(self, other): ...

class Heur:
    model: Incomplete
    name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def heurexec(self, *args, **kwargs): ...
    def heurexit(self, *args, **kwargs): ...
    def heurexitsol(self, *args, **kwargs): ...
    def heurfree(self, *args, **kwargs): ...
    def heurinit(self, *args, **kwargs): ...
    def heurinitsol(self, *args, **kwargs): ...

class IIS:
    def __init__(self, *args, **kwargs) -> None: ...
    def getNNodes(self, *args, **kwargs): ...
    def getSubscip(self, *args, **kwargs): ...
    def getTime(self, *args, **kwargs): ...
    def greedyMakeIrreducible(self, *args, **kwargs): ...
    def isSubscipInfeasible(self, *args, **kwargs): ...
    def isSubscipIrreducible(self, *args, **kwargs): ...
    def setSubscipInfeasible(self, *args, **kwargs): ...
    def setSubscipIrreducible(self, *args, **kwargs): ...

class IISfinder:
    iis: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def iisfinderexec(self, *args, **kwargs): ...
    def iisfinderfree(self, *args, **kwargs): ...

class LP:
    name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def addCol(self, *args, **kwargs): ...
    def addCols(self, *args, **kwargs): ...
    def addRow(self, *args, **kwargs): ...
    def addRows(self, *args, **kwargs): ...
    def chgBound(self, *args, **kwargs): ...
    def chgCoef(self, *args, **kwargs): ...
    def chgObj(self, *args, **kwargs): ...
    def chgSide(self, *args, **kwargs): ...
    def clear(self, *args, **kwargs): ...
    def delCols(self, *args, **kwargs): ...
    def delRows(self, *args, **kwargs): ...
    def getActivity(self, *args, **kwargs): ...
    def getBasisInds(self, *args, **kwargs): ...
    def getBounds(self, *args, **kwargs): ...
    def getDual(self, *args, **kwargs): ...
    def getDualRay(self, *args, **kwargs): ...
    def getIntParam(self, *args, **kwargs): ...
    def getNIterations(self, *args, **kwargs): ...
    def getObjVal(self, *args, **kwargs): ...
    def getPrimal(self, *args, **kwargs): ...
    def getPrimalRay(self, *args, **kwargs): ...
    def getRealParam(self, *args, **kwargs): ...
    def getRedcost(self, *args, **kwargs): ...
    def getSides(self, *args, **kwargs): ...
    def infinity(self, *args, **kwargs): ...
    def isDualFeasible(self, *args, **kwargs): ...
    def isInfinity(self, *args, **kwargs): ...
    def isOptimal(self, *args, **kwargs): ...
    def isPrimalFeasible(self, *args, **kwargs): ...
    def ncols(self, *args, **kwargs): ...
    def nrows(self, *args, **kwargs): ...
    def readLP(self, *args, **kwargs): ...
    def setIntParam(self, *args, **kwargs): ...
    def setRealParam(self, *args, **kwargs): ...
    def solve(self, *args, **kwargs): ...
    def writeLP(self, *args, **kwargs): ...

class MatrixConstraint(numpy.ndarray):
    def getConshdlrName(self, *args, **kwargs): ...
    def isActive(self, *args, **kwargs): ...
    def isChecked(self, *args, **kwargs): ...
    def isDynamic(self, *args, **kwargs): ...
    def isEnforced(self, *args, **kwargs): ...
    def isInitial(self, *args, **kwargs): ...
    def isLinear(self, *args, **kwargs): ...
    def isLocal(self, *args, **kwargs): ...
    def isModifiable(self, *args, **kwargs): ...
    def isNonlinear(self, *args, **kwargs): ...
    def isPropagated(self, *args, **kwargs): ...
    def isRemovable(self, *args, **kwargs): ...
    def isSeparated(self, *args, **kwargs): ...
    def isStickingAtNode(self, *args, **kwargs): ...

class MatrixExpr(numpy.ndarray):
    def sum(self, *args, **kwargs): ...
    def __add__(self, other): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> MatrixExprCons: ...
    def __iadd__(self, other): ...
    def __le__(self, other: object) -> MatrixExprCons: ...
    def __matmul__(self, *args, **kwargs): ...
    def __mul__(self, other): ...
    def __pow__(self, other): ...
    def __radd__(self, other): ...
    def __rmul__(self, other): ...
    def __rsub__(self, other): ...
    def __rtruediv__(self, other): ...
    def __sub__(self, other): ...
    def __truediv__(self, other): ...

class MatrixExprCons(numpy.ndarray):
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> MatrixExprCons: ...
    def __le__(self, other: object) -> MatrixExprCons: ...

class MatrixGenExpr(MatrixExpr):
    ...

class MatrixVariable(MatrixExpr):
    def getAvgSol(self, *args, **kwargs): ...
    def getCol(self, *args, **kwargs): ...
    def getIndex(self, *args, **kwargs): ...
    def getLPSol(self, *args, **kwargs): ...
    def getLbGlobal(self, *args, **kwargs): ...
    def getLbLocal(self, *args, **kwargs): ...
    def getLbOriginal(self, *args, **kwargs): ...
    def getObj(self, *args, **kwargs): ...
    def getUbGlobal(self, *args, **kwargs): ...
    def getUbLocal(self, *args, **kwargs): ...
    def getUbOriginal(self, *args, **kwargs): ...
    def isInLP(self, *args, **kwargs): ...
    def varMayRound(self, *args, **kwargs): ...
    def vtype(self, *args, **kwargs): ...

class Model:
    _freescip: Incomplete
    data: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def _createConsGenNonlinear(self, *args, **kwargs): ...
    def _createConsLinear(self, *args, **kwargs): ...
    def _createConsNonlinear(self, *args, **kwargs): ...
    def _createConsQuadratic(self, *args, **kwargs): ...
    def _getStageNames(self, *args, **kwargs): ...
    def activateBenders(self, *args, **kwargs): ...
    def addBendersSubproblem(self, *args, **kwargs): ...
    def addCoefKnapsack(self, *args, **kwargs): ...
    def addCoefLinear(self, *args, **kwargs): ...
    def addCons(self, *args, **kwargs): ...
    def addConsAnd(self, *args, **kwargs): ...
    def addConsCardinality(self, *args, **kwargs): ...
    def addConsCoeff(self, *args, **kwargs): ...
    def addConsDisjunction(self, *args, **kwargs): ...
    def addConsElemDisjunction(self, *args, **kwargs): ...
    def addConsIndicator(self, *args, **kwargs): ...
    def addConsKnapsack(self, *args, **kwargs): ...
    def addConsLocal(self, *args, **kwargs): ...
    def addConsNode(self, *args, **kwargs): ...
    def addConsOr(self, *args, **kwargs): ...
    def addConsSOS1(self, *args, **kwargs): ...
    def addConsSOS2(self, *args, **kwargs): ...
    def addConsXor(self, *args, **kwargs): ...
    def addConss(self, *args, **kwargs): ...
    def addCut(self, *args, **kwargs): ...
    def addExprNonlinear(self, *args, **kwargs): ...
    def addMatrixCons(self, *args, **kwargs): ...
    def addMatrixConsIndicator(self, *args, **kwargs): ...
    def addMatrixVar(self, *args, **kwargs): ...
    def addObjoffset(self, *args, **kwargs): ...
    def addPoolCut(self, *args, **kwargs): ...
    def addPyCons(self, *args, **kwargs): ...
    def addRowDive(self, *args, **kwargs): ...
    def addRowExact(self, *args, **kwargs): ...
    def addSol(self, *args, **kwargs): ...
    def addVar(self, *args, **kwargs): ...
    def addVarLocks(self, *args, **kwargs): ...
    def addVarLocksType(self, *args, **kwargs): ...
    def addVarSOS1(self, *args, **kwargs): ...
    def addVarSOS2(self, *args, **kwargs): ...
    def addVarToRow(self, *args, **kwargs): ...
    def allColsInLP(self, *args, **kwargs): ...
    def allowNegSlackExact(self, *args, **kwargs): ...
    def appendVarSOS1(self, *args, **kwargs): ...
    def appendVarSOS2(self, *args, **kwargs): ...
    def applyCutsProbing(self, *args, **kwargs): ...
    def attachEventHandlerCallback(self, *args, **kwargs): ...
    def backtrackProbing(self, *args, **kwargs): ...
    def branchLPExact(self, *args, **kwargs): ...
    def branchVar(self, *args, **kwargs): ...
    def branchVarVal(self, *args, **kwargs): ...
    def cacheRowExtensions(self, *args, **kwargs): ...
    def calcChildEstimate(self, *args, **kwargs): ...
    def calcNodeselPriority(self, *args, **kwargs): ...
    def catchEvent(self, *args, **kwargs): ...
    def catchRowEvent(self, *args, **kwargs): ...
    def catchVarEvent(self, *args, **kwargs): ...
    def checkBendersSubproblemOptimality(self, *args, **kwargs): ...
    def checkQuadraticNonlinear(self, *args, **kwargs): ...
    def checkSol(self, *args, **kwargs): ...
    def chgCapacityKnapsack(self, *args, **kwargs): ...
    def chgCoefLinear(self, *args, **kwargs): ...
    def chgLhs(self, *args, **kwargs): ...
    def chgReoptObjective(self, *args, **kwargs): ...
    def chgRhs(self, *args, **kwargs): ...
    def chgRowLhsDive(self, *args, **kwargs): ...
    def chgRowRhsDive(self, *args, **kwargs): ...
    def chgVarBranchPriority(self, *args, **kwargs): ...
    def chgVarLb(self, *args, **kwargs): ...
    def chgVarLbDive(self, *args, **kwargs): ...
    def chgVarLbGlobal(self, *args, **kwargs): ...
    def chgVarLbNode(self, *args, **kwargs): ...
    def chgVarLbProbing(self, *args, **kwargs): ...
    def chgVarObjDive(self, *args, **kwargs): ...
    def chgVarObjProbing(self, *args, **kwargs): ...
    def chgVarType(self, *args, **kwargs): ...
    def chgVarUb(self, *args, **kwargs): ...
    def chgVarUbDive(self, *args, **kwargs): ...
    def chgVarUbGlobal(self, *args, **kwargs): ...
    def chgVarUbNode(self, *args, **kwargs): ...
    def chgVarUbProbing(self, *args, **kwargs): ...
    def computeBestSolSubproblems(self, *args, **kwargs): ...
    def constructLP(self, *args, **kwargs): ...
    def copyLargeNeighborhoodSearch(self, *args, **kwargs): ...
    def count(self, *args, **kwargs): ...
    def createChild(self, *args, **kwargs): ...
    def createCons(self, *args, **kwargs): ...
    def createConsFromExpr(self, *args, **kwargs): ...
    def createEmptyRowSepa(self, *args, **kwargs): ...
    def createEmptyRowUnspec(self, *args, **kwargs): ...
    def createOrigSol(self, *args, **kwargs): ...
    def createPartialSol(self, *args, **kwargs): ...
    def createProbBasic(self, *args, **kwargs): ...
    def createSol(self, *args, **kwargs): ...
    def cutoffNode(self, *args, **kwargs): ...
    def deactivatePricer(self, *args, **kwargs): ...
    def delCoefLinear(self, *args, **kwargs): ...
    def delCons(self, *args, **kwargs): ...
    def delConsLocal(self, *args, **kwargs): ...
    def delVar(self, *args, **kwargs): ...
    def disableDebugSol(self, *args, **kwargs): ...
    def disablePropagation(self, *args, **kwargs): ...
    def dropEvent(self, *args, **kwargs): ...
    def dropRowEvent(self, *args, **kwargs): ...
    def dropVarEvent(self, *args, **kwargs): ...
    def enableDebugSol(self, *args, **kwargs): ...
    def enableExactSolving(self, *args, **kwargs): ...
    def enableReoptimization(self, *args, **kwargs): ...
    def endDive(self, *args, **kwargs): ...
    def endProbing(self, *args, **kwargs): ...
    def endStrongbranch(self, *args, **kwargs): ...
    def epsilon(self, *args, **kwargs): ...
    def feasCeil(self, *args, **kwargs): ...
    def feasFloor(self, *args, **kwargs): ...
    def feasFrac(self, *args, **kwargs): ...
    def feasRound(self, *args, **kwargs): ...
    def feastol(self, *args, **kwargs): ...
    def fixVar(self, *args, **kwargs): ...
    def fixVarProbing(self, *args, **kwargs): ...
    def flushRowExtensions(self, *args, **kwargs): ...
    def frac(self, *args, **kwargs): ...
    def freeBendersSubproblems(self, *args, **kwargs): ...
    def freeProb(self, *args, **kwargs): ...
    def freeReoptSolve(self, *args, **kwargs): ...
    def freeSol(self, *args, **kwargs): ...
    def freeTransform(self, *args, **kwargs): ...
    @staticmethod
    def from_ptr(*args, **kwargs): ...
    def generateIIS(self, *args, **kwargs): ...
    def getActivity(self, *args, **kwargs): ...
    def getBendersAuxiliaryVar(self, *args, **kwargs): ...
    def getBendersSubproblem(self, *args, **kwargs): ...
    def getBendersVar(self, *args, **kwargs): ...
    def getBestChild(self, *args, **kwargs): ...
    def getBestLeaf(self, *args, **kwargs): ...
    def getBestNode(self, *args, **kwargs): ...
    def getBestSibling(self, *args, **kwargs): ...
    def getBestSol(self, *args, **kwargs): ...
    def getBestboundNode(self, *args, **kwargs): ...
    def getBipartiteGraphRepresentation(self, *args, **kwargs): ...
    def getBranchScoreMultiple(self, *args, **kwargs): ...
    def getCapacityKnapsack(self, *args, **kwargs): ...
    def getChildren(self, *args, **kwargs): ...
    def getColRedCost(self, *args, **kwargs): ...
    def getCondition(self, *args, **kwargs): ...
    def getConsNVars(self, *args, **kwargs): ...
    def getConsVals(self, *args, **kwargs): ...
    def getConsVars(self, *args, **kwargs): ...
    def getConss(self, *args, **kwargs): ...
    def getCurrentNode(self, *args, **kwargs): ...
    def getCutEfficacy(self, *args, **kwargs): ...
    def getCutLPSolCutoffDistance(self, *args, **kwargs): ...
    def getCutoffbound(self, *args, **kwargs): ...
    def getDepth(self, *args, **kwargs): ...
    def getDualMultiplier(self, *args, **kwargs): ...
    def getDualSolVal(self, *args, **kwargs): ...
    def getDualbound(self, *args, **kwargs): ...
    def getDualboundRoot(self, *args, **kwargs): ...
    def getDualfarkasKnapsack(self, *args, **kwargs): ...
    def getDualfarkasLinear(self, *args, **kwargs): ...
    def getDualsolKnapsack(self, *args, **kwargs): ...
    def getDualsolLinear(self, *args, **kwargs): ...
    def getGap(self, *args, **kwargs): ...
    def getHeurTiming(self, *args, **kwargs): ...
    def getIIS(self, *args, **kwargs): ...
    def getLPBInvARow(self, *args, **kwargs): ...
    def getLPBInvRow(self, *args, **kwargs): ...
    def getLPBasisInd(self, *args, **kwargs): ...
    def getLPBranchCands(self, *args, **kwargs): ...
    def getLPColsData(self, *args, **kwargs): ...
    def getLPObjVal(self, *args, **kwargs): ...
    def getLPRowsData(self, *args, **kwargs): ...
    def getLPSolstat(self, *args, **kwargs): ...
    def getLeaves(self, *args, **kwargs): ...
    def getLhs(self, *args, **kwargs): ...
    def getLinearConsIndicator(self, *args, **kwargs): ...
    def getLocalEstimate(self, *args, **kwargs): ...
    def getLowerbound(self, *args, **kwargs): ...
    def getMajorVersion(self, *args, **kwargs): ...
    def getMaxDepth(self, *args, **kwargs): ...
    def getMinorVersion(self, *args, **kwargs): ...
    def getNBestSolsFound(self, *args, **kwargs): ...
    def getNBinVars(self, *args, **kwargs): ...
    def getNChildren(self, *args, **kwargs): ...
    def getNConss(self, *args, **kwargs): ...
    def getNContVars(self, *args, **kwargs): ...
    def getNCountedSols(self, *args, **kwargs): ...
    def getNCuts(self, *args, **kwargs): ...
    def getNCutsApplied(self, *args, **kwargs): ...
    def getNFeasibleLeaves(self, *args, **kwargs): ...
    def getNImplVars(self, *args, **kwargs): ...
    def getNInfeasibleLeaves(self, *args, **kwargs): ...
    def getNIntVars(self, *args, **kwargs): ...
    def getNLPBranchCands(self, *args, **kwargs): ...
    def getNLPCols(self, *args, **kwargs): ...
    def getNLPIterations(self, *args, **kwargs): ...
    def getNLPRows(self, *args, **kwargs): ...
    def getNLPs(self, *args, **kwargs): ...
    def getNLeaves(self, *args, **kwargs): ...
    def getNLimSolsFound(self, *args, **kwargs): ...
    def getNNlRows(self, *args, **kwargs): ...
    def getNNodeLPIterations(self, *args, **kwargs): ...
    def getNNodes(self, *args, **kwargs): ...
    def getNReaders(self, *args, **kwargs): ...
    def getNSepaRounds(self, *args, **kwargs): ...
    def getNSiblings(self, *args, **kwargs): ...
    def getNSols(self, *args, **kwargs): ...
    def getNSolsFound(self, *args, **kwargs): ...
    def getNStrongbranchLPIterations(self, *args, **kwargs): ...
    def getNTotalNodes(self, *args, **kwargs): ...
    def getNVars(self, *args, **kwargs): ...
    def getNVarsAnd(self, *args, **kwargs): ...
    def getNlRowActivityBounds(self, *args, **kwargs): ...
    def getNlRowSolActivity(self, *args, **kwargs): ...
    def getNlRowSolFeasibility(self, *args, **kwargs): ...
    def getNlRows(self, *args, **kwargs): ...
    def getObjVal(self, *args, **kwargs): ...
    def getObjective(self, *args, **kwargs): ...
    def getObjectiveSense(self, *args, **kwargs): ...
    def getObjlimit(self, *args, **kwargs): ...
    def getObjoffset(self, *args, **kwargs): ...
    def getOpenNodes(self, *args, **kwargs): ...
    def getParam(self, *args, **kwargs): ...
    def getParams(self, *args, **kwargs): ...
    def getPlungeDepth(self, *args, **kwargs): ...
    def getPresolvingTime(self, *args, **kwargs): ...
    def getPrimalRay(self, *args, **kwargs): ...
    def getPrimalRayVal(self, *args, **kwargs): ...
    def getPrimalbound(self, *args, **kwargs): ...
    def getPrioChild(self, *args, **kwargs): ...
    def getPrioSibling(self, *args, **kwargs): ...
    def getProbName(self, *args, **kwargs): ...
    def getProbingDepth(self, *args, **kwargs): ...
    def getPseudoBranchCands(self, *args, **kwargs): ...
    def getReadingTime(self, *args, **kwargs): ...
    def getResultantAnd(self, *args, **kwargs): ...
    def getRhs(self, *args, **kwargs): ...
    def getRowActivity(self, *args, **kwargs): ...
    def getRowDualSol(self, *args, **kwargs): ...
    def getRowLPActivity(self, *args, **kwargs): ...
    def getRowLinear(self, *args, **kwargs): ...
    def getRowNumIntCols(self, *args, **kwargs): ...
    def getRowObjParallelism(self, *args, **kwargs): ...
    def getRowParallelism(self, *args, **kwargs): ...
    def getSiblings(self, *args, **kwargs): ...
    def getSlack(self, *args, **kwargs): ...
    def getSlackVarIndicator(self, *args, **kwargs): ...
    def getSolObjVal(self, *args, **kwargs): ...
    def getSolTime(self, *args, **kwargs): ...
    def getSolVal(self, *args, **kwargs): ...
    def getSols(self, *args, **kwargs): ...
    def getSolvingTime(self, *args, **kwargs): ...
    def getStage(self, *args, **kwargs): ...
    def getStageName(self, *args, **kwargs): ...
    def getStatus(self, *args, **kwargs): ...
    def getTechVersion(self, *args, **kwargs): ...
    def getTermsQuadratic(self, *args, **kwargs): ...
    def getTotalTime(self, *args, **kwargs): ...
    def getTransformedCons(self, *args, **kwargs): ...
    def getTransformedVar(self, *args, **kwargs): ...
    def getTreesizeEstimation(self, *args, **kwargs): ...
    def getVal(self, *args, **kwargs): ...
    def getValsLinear(self, *args, **kwargs): ...
    def getVarDict(self, *args, **kwargs): ...
    def getVarLbDive(self, *args, **kwargs): ...
    def getVarPseudocost(self, *args, **kwargs): ...
    def getVarPseudocostScore(self, *args, **kwargs): ...
    def getVarRedcost(self, *args, **kwargs): ...
    def getVarStrongbranch(self, *args, **kwargs): ...
    def getVarStrongbranchLast(self, *args, **kwargs): ...
    def getVarStrongbranchNode(self, *args, **kwargs): ...
    def getVarUbDive(self, *args, **kwargs): ...
    def getVars(self, *args, **kwargs): ...
    def getVarsAnd(self, *args, **kwargs): ...
    def getWeightsKnapsack(self, *args, **kwargs): ...
    def hasPrimalRay(self, *args, **kwargs): ...
    def hideOutput(self, *args, **kwargs): ...
    def inProbing(self, *args, **kwargs): ...
    def inRepropagation(self, *args, **kwargs): ...
    def includeBenders(self, *args, **kwargs): ...
    def includeBendersDefaultCuts(self, *args, **kwargs): ...
    def includeBenderscut(self, *args, **kwargs): ...
    def includeBranchrule(self, *args, **kwargs): ...
    def includeConshdlr(self, *args, **kwargs): ...
    def includeCutsel(self, *args, **kwargs): ...
    def includeDefaultPlugins(self, *args, **kwargs): ...
    def includeEventhdlr(self, *args, **kwargs): ...
    def includeHeur(self, *args, **kwargs): ...
    def includeIISfinder(self, *args, **kwargs): ...
    def includeNodesel(self, *args, **kwargs): ...
    def includePresol(self, *args, **kwargs): ...
    def includePricer(self, *args, **kwargs): ...
    def includeProp(self, *args, **kwargs): ...
    def includeReader(self, *args, **kwargs): ...
    def includeRelax(self, *args, **kwargs): ...
    def includeSepa(self, *args, **kwargs): ...
    def infinity(self, *args, **kwargs): ...
    def initBendersDefault(self, *args, **kwargs): ...
    def interruptSolve(self, *args, **kwargs): ...
    def isAndConsSorted(self, *args, **kwargs): ...
    def isCutEfficacious(self, *args, **kwargs): ...
    def isEQ(self, *args, **kwargs): ...
    def isExact(self, *args, **kwargs): ...
    def isFeasEQ(self, *args, **kwargs): ...
    def isFeasGE(self, *args, **kwargs): ...
    def isFeasGT(self, *args, **kwargs): ...
    def isFeasIntegral(self, *args, **kwargs): ...
    def isFeasLE(self, *args, **kwargs): ...
    def isFeasLT(self, *args, **kwargs): ...
    def isFeasNegative(self, *args, **kwargs): ...
    def isFeasPositive(self, *args, **kwargs): ...
    def isFeasZero(self, *args, **kwargs): ...
    def isGE(self, *args, **kwargs): ...
    def isGT(self, *args, **kwargs): ...
    def isHugeValue(self, *args, **kwargs): ...
    def isInfinity(self, *args, **kwargs): ...
    def isLE(self, *args, **kwargs): ...
    def isLPSolBasic(self, *args, **kwargs): ...
    def isLT(self, *args, **kwargs): ...
    def isNLPConstructed(self, *args, **kwargs): ...
    def isNegative(self, *args, **kwargs): ...
    def isObjChangedProbing(self, *args, **kwargs): ...
    def isPositive(self, *args, **kwargs): ...
    def isZero(self, *args, **kwargs): ...
    def lpiGetIterations(self, *args, **kwargs): ...
    def markDoNotAggrVar(self, *args, **kwargs): ...
    def markDoNotMultaggrVar(self, *args, **kwargs): ...
    def newProbingNode(self, *args, **kwargs): ...
    def optimize(self, *args, **kwargs): ...
    def optimizeNogil(self, *args, **kwargs): ...
    def presolve(self, *args, **kwargs): ...
    def printBestSol(self, *args, **kwargs): ...
    def printCons(self, *args, **kwargs): ...
    def printExternalCodeVersions(self, *args, **kwargs): ...
    def printNlRow(self, *args, **kwargs): ...
    def printProblem(self, *args, **kwargs): ...
    def printRow(self, *args, **kwargs): ...
    def printSol(self, *args, **kwargs): ...
    def printStatistics(self, *args, **kwargs): ...
    def printStatisticsJson(self, *args, **kwargs): ...
    def printVersion(self, *args, **kwargs): ...
    def propagateProbing(self, *args, **kwargs): ...
    def readParams(self, *args, **kwargs): ...
    def readProblem(self, *args, **kwargs): ...
    def readSol(self, *args, **kwargs): ...
    def readSolFile(self, *args, **kwargs): ...
    def redirectOutput(self, *args, **kwargs): ...
    def relax(self, *args, **kwargs): ...
    def releaseRow(self, *args, **kwargs): ...
    def repropagateNode(self, *args, **kwargs): ...
    def resetParam(self, *args, **kwargs): ...
    def resetParams(self, *args, **kwargs): ...
    def restartSolve(self, *args, **kwargs): ...
    def separateSol(self, *args, **kwargs): ...
    def setBendersSubproblemIsConvex(self, *args, **kwargs): ...
    def setBoolParam(self, *args, **kwargs): ...
    def setCharParam(self, *args, **kwargs): ...
    def setCheck(self, *args, **kwargs): ...
    def setEmphasis(self, *args, **kwargs): ...
    def setEnforced(self, *args, **kwargs): ...
    def setHeurTiming(self, *args, **kwargs): ...
    def setHeuristics(self, *args, **kwargs): ...
    def setInitial(self, *args, **kwargs): ...
    def setIntParam(self, *args, **kwargs): ...
    def setLogfile(self, *args, **kwargs): ...
    def setLongintParam(self, *args, **kwargs): ...
    def setMaximize(self, *args, **kwargs): ...
    def setMinimize(self, *args, **kwargs): ...
    def setModifiable(self, *args, **kwargs): ...
    def setObjIntegral(self, *args, **kwargs): ...
    def setObjective(self, *args, **kwargs): ...
    def setObjlimit(self, *args, **kwargs): ...
    def setParam(self, *args, **kwargs): ...
    def setParams(self, *args, **kwargs): ...
    def setParamsCountsols(self, *args, **kwargs): ...
    def setPresolve(self, *args, **kwargs): ...
    def setProbName(self, *args, **kwargs): ...
    def setRealParam(self, *args, **kwargs): ...
    def setRelaxSolVal(self, *args, **kwargs): ...
    def setRemovable(self, *args, **kwargs): ...
    def setSeparating(self, *args, **kwargs): ...
    def setSolVal(self, *args, **kwargs): ...
    def setStringParam(self, *args, **kwargs): ...
    def setupBendersSubproblem(self, *args, **kwargs): ...
    def solveBendersSubproblem(self, *args, **kwargs): ...
    def solveConcurrent(self, *args, **kwargs): ...
    def solveDiveLP(self, *args, **kwargs): ...
    def solveProbingLP(self, *args, **kwargs): ...
    def sortAndCons(self, *args, **kwargs): ...
    def startDive(self, *args, **kwargs): ...
    def startProbing(self, *args, **kwargs): ...
    def startStrongbranch(self, *args, **kwargs): ...
    def tightenVarLb(self, *args, **kwargs): ...
    def tightenVarLbGlobal(self, *args, **kwargs): ...
    def tightenVarUb(self, *args, **kwargs): ...
    def tightenVarUbGlobal(self, *args, **kwargs): ...
    def to_ptr(self, *args, **kwargs): ...
    def translateSubSol(self, *args, **kwargs): ...
    def trySol(self, *args, **kwargs): ...
    def updateBendersLowerbounds(self, *args, **kwargs): ...
    def updateNodeLowerbound(self, *args, **kwargs): ...
    def updateVarPseudocost(self, *args, **kwargs): ...
    def version(self, *args, **kwargs): ...
    def writeBestSol(self, *args, **kwargs): ...
    def writeBestTransSol(self, *args, **kwargs): ...
    def writeLP(self, *args, **kwargs): ...
    def writeMIP(self, *args, **kwargs): ...
    def writeName(self, *args, **kwargs): ...
    def writeParams(self, *args, **kwargs): ...
    def writeProblem(self, *args, **kwargs): ...
    def writeSol(self, *args, **kwargs): ...
    def writeStatistics(self, *args, **kwargs): ...
    def writeStatisticsJson(self, *args, **kwargs): ...
    def writeTransSol(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class NLRow:
    data: Incomplete
    name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def getConstant(self, *args, **kwargs): ...
    def getDualsol(self, *args, **kwargs): ...
    def getLhs(self, *args, **kwargs): ...
    def getLinearTerms(self, *args, **kwargs): ...
    def getRhs(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Node:
    data: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def getAddedConss(self, *args, **kwargs): ...
    def getDepth(self, *args, **kwargs): ...
    def getDomchg(self, *args, **kwargs): ...
    def getEstimate(self, *args, **kwargs): ...
    def getLowerbound(self, *args, **kwargs): ...
    def getNAddedConss(self, *args, **kwargs): ...
    def getNDomchg(self, *args, **kwargs): ...
    def getNParentBranchings(self, *args, **kwargs): ...
    def getNumber(self, *args, **kwargs): ...
    def getParent(self, *args, **kwargs): ...
    def getParentBranchings(self, *args, **kwargs): ...
    def getType(self, *args, **kwargs): ...
    def isActive(self, *args, **kwargs): ...
    def isPropagatedAgain(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Nodesel:
    model: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def nodecomp(self, *args, **kwargs): ...
    def nodeexit(self, *args, **kwargs): ...
    def nodeexitsol(self, *args, **kwargs): ...
    def nodefree(self, *args, **kwargs): ...
    def nodeinit(self, *args, **kwargs): ...
    def nodeinitsol(self, *args, **kwargs): ...
    def nodeselect(self, *args, **kwargs): ...

class Op:
    add: ClassVar[str] = ...
    const: ClassVar[str] = ...
    cos: ClassVar[str] = ...
    div: ClassVar[str] = ...
    exp: ClassVar[str] = ...
    fabs: ClassVar[str] = ...
    log: ClassVar[str] = ...
    minus: ClassVar[str] = ...
    mul: ClassVar[str] = ...
    plus: ClassVar[str] = ...
    power: ClassVar[str] = ...
    prod: ClassVar[str] = ...
    sin: ClassVar[str] = ...
    sqrt: ClassVar[str] = ...
    varidx: ClassVar[str] = ...

class PY_SCIP_BENDERSENFOTYPE:
    CHECK: ClassVar[int] = ...
    LP: ClassVar[int] = ...
    PSEUDO: ClassVar[int] = ...
    RELAX: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_BRANCHDIR:
    AUTO: ClassVar[int] = ...
    DOWNWARDS: ClassVar[int] = ...
    FIXED: ClassVar[int] = ...
    UPWARDS: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_EVENTTYPE:
    BESTSOLFOUND: ClassVar[int] = ...
    BOUNDCHANGED: ClassVar[int] = ...
    BOUNDRELAXED: ClassVar[int] = ...
    BOUNDTIGHTENED: ClassVar[int] = ...
    DISABLED: ClassVar[int] = ...
    DOMCHANGED: ClassVar[int] = ...
    DUALBOUNDIMPROVED: ClassVar[int] = ...
    FIRSTLPSOLVED: ClassVar[int] = ...
    GAPUPDATED: ClassVar[int] = ...
    GBDCHANGED: ClassVar[int] = ...
    GHOLEADDED: ClassVar[int] = ...
    GHOLECHANGED: ClassVar[int] = ...
    GHOLEREMOVED: ClassVar[int] = ...
    GLBCHANGED: ClassVar[int] = ...
    GUBCHANGED: ClassVar[int] = ...
    HOLECHANGED: ClassVar[int] = ...
    IMPLADDED: ClassVar[int] = ...
    LBCHANGED: ClassVar[int] = ...
    LBRELAXED: ClassVar[int] = ...
    LBTIGHTENED: ClassVar[int] = ...
    LHOLEADDED: ClassVar[int] = ...
    LHOLECHANGED: ClassVar[int] = ...
    LHOLEREMOVED: ClassVar[int] = ...
    LPEVENT: ClassVar[int] = ...
    LPSOLVED: ClassVar[int] = ...
    NODEBRANCHED: ClassVar[int] = ...
    NODEDELETE: ClassVar[int] = ...
    NODEEVENT: ClassVar[int] = ...
    NODEFEASIBLE: ClassVar[int] = ...
    NODEFOCUSED: ClassVar[int] = ...
    NODEINFEASIBLE: ClassVar[int] = ...
    NODESOLVED: ClassVar[int] = ...
    OBJCHANGED: ClassVar[int] = ...
    POORSOLFOUND: ClassVar[int] = ...
    PRESOLVEROUND: ClassVar[int] = ...
    ROWADDEDLP: ClassVar[int] = ...
    ROWADDEDSEPA: ClassVar[int] = ...
    ROWCHANGED: ClassVar[int] = ...
    ROWCOEFCHANGED: ClassVar[int] = ...
    ROWCONSTCHANGED: ClassVar[int] = ...
    ROWDELETEDLP: ClassVar[int] = ...
    ROWDELETEDSEPA: ClassVar[int] = ...
    ROWEVENT: ClassVar[int] = ...
    ROWSIDECHANGED: ClassVar[int] = ...
    SOLEVENT: ClassVar[int] = ...
    SOLFOUND: ClassVar[int] = ...
    SYNC: ClassVar[int] = ...
    UBCHANGED: ClassVar[int] = ...
    UBRELAXED: ClassVar[int] = ...
    UBTIGHTENED: ClassVar[int] = ...
    VARADDED: ClassVar[int] = ...
    VARCHANGED: ClassVar[int] = ...
    VARDELETED: ClassVar[int] = ...
    VAREVENT: ClassVar[int] = ...
    VARFIXED: ClassVar[int] = ...
    VARUNLOCKED: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_HEURTIMING:
    AFTERLPLOOP: ClassVar[int] = ...
    AFTERLPNODE: ClassVar[int] = ...
    AFTERLPPLUNGE: ClassVar[int] = ...
    AFTERPROPLOOP: ClassVar[int] = ...
    AFTERPSEUDONODE: ClassVar[int] = ...
    AFTERPSEUDOPLUNGE: ClassVar[int] = ...
    BEFORENODE: ClassVar[int] = ...
    BEFOREPRESOL: ClassVar[int] = ...
    DURINGLPLOOP: ClassVar[int] = ...
    DURINGPRESOLLOOP: ClassVar[int] = ...
    DURINGPRICINGLOOP: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_IMPLINTTYPE:
    NONE: ClassVar[int] = ...
    STRONG: ClassVar[int] = ...
    WEAK: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_LOCKTYPE:
    CONFLICT: ClassVar[int] = ...
    MODEL: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_LPPARAM:
    BARRIERCONVTOL: ClassVar[int] = ...
    CONDITIONLIMIT: ClassVar[int] = ...
    DUALFEASTOL: ClassVar[int] = ...
    FASTMIP: ClassVar[int] = ...
    FEASTOL: ClassVar[int] = ...
    FROMSCRATCH: ClassVar[int] = ...
    LPINFO: ClassVar[int] = ...
    LPITLIM: ClassVar[int] = ...
    LPTILIM: ClassVar[int] = ...
    MARKOWITZ: ClassVar[int] = ...
    OBJLIM: ClassVar[int] = ...
    POLISHING: ClassVar[int] = ...
    PRESOLVING: ClassVar[int] = ...
    PRICING: ClassVar[int] = ...
    RANDOMSEED: ClassVar[int] = ...
    REFACTOR: ClassVar[int] = ...
    ROWREPSWITCH: ClassVar[int] = ...
    SCALING: ClassVar[int] = ...
    THREADS: ClassVar[int] = ...
    TIMING: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_LPSOLSTAT:
    ERROR: ClassVar[int] = ...
    INFEASIBLE: ClassVar[int] = ...
    ITERLIMIT: ClassVar[int] = ...
    NOTSOLVED: ClassVar[int] = ...
    OBJLIMIT: ClassVar[int] = ...
    OPTIMAL: ClassVar[int] = ...
    TIMELIMIT: ClassVar[int] = ...
    UNBOUNDEDRAY: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_NODETYPE:
    CHILD: ClassVar[int] = ...
    DEADEND: ClassVar[int] = ...
    FOCUSNODE: ClassVar[int] = ...
    FORK: ClassVar[int] = ...
    JUNCTION: ClassVar[int] = ...
    LEAF: ClassVar[int] = ...
    PROBINGNODE: ClassVar[int] = ...
    PSEUDOFORK: ClassVar[int] = ...
    REFOCUSNODE: ClassVar[int] = ...
    SIBLING: ClassVar[int] = ...
    SUBROOT: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_PARAMEMPHASIS:
    BENCHMARK: ClassVar[int] = ...
    COUNTER: ClassVar[int] = ...
    CPSOLVER: ClassVar[int] = ...
    DEFAULT: ClassVar[int] = ...
    EASYCIP: ClassVar[int] = ...
    FEASIBILITY: ClassVar[int] = ...
    HARDLP: ClassVar[int] = ...
    NUMERICS: ClassVar[int] = ...
    OPTIMALITY: ClassVar[int] = ...
    PHASEFEAS: ClassVar[int] = ...
    PHASEIMPROVE: ClassVar[int] = ...
    PHASEPROOF: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_PARAMSETTING:
    AGGRESSIVE: ClassVar[int] = ...
    DEFAULT: ClassVar[int] = ...
    FAST: ClassVar[int] = ...
    OFF: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_PRESOLTIMING:
    EXHAUSTIVE: ClassVar[int] = ...
    FAST: ClassVar[int] = ...
    MEDIUM: ClassVar[int] = ...
    NONE: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_PROPTIMING:
    AFTERLPLOOP: ClassVar[int] = ...
    AFTERLPNODE: ClassVar[int] = ...
    BEFORELP: ClassVar[int] = ...
    DURINGLPLOOP: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_RESULT:
    BRANCHED: ClassVar[int] = ...
    CONSADDED: ClassVar[int] = ...
    CONSCHANGED: ClassVar[int] = ...
    CUTOFF: ClassVar[int] = ...
    DELAYED: ClassVar[int] = ...
    DIDNOTFIND: ClassVar[int] = ...
    DIDNOTRUN: ClassVar[int] = ...
    FEASIBLE: ClassVar[int] = ...
    FOUNDSOL: ClassVar[int] = ...
    INFEASIBLE: ClassVar[int] = ...
    NEWROUND: ClassVar[int] = ...
    REDUCEDDOM: ClassVar[int] = ...
    SEPARATED: ClassVar[int] = ...
    SOLVELP: ClassVar[int] = ...
    SUCCESS: ClassVar[int] = ...
    SUSPENDED: ClassVar[int] = ...
    UNBOUNDED: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_ROWORIGINTYPE:
    CONS: ClassVar[int] = ...
    REOPT: ClassVar[int] = ...
    SEPA: ClassVar[int] = ...
    UNSPEC: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_SOLORIGIN:
    LPSOL: ClassVar[int] = ...
    NLPSOL: ClassVar[int] = ...
    ORIGINAL: ClassVar[int] = ...
    PARTIAL: ClassVar[int] = ...
    PSEUDOSOL: ClassVar[int] = ...
    RELAXSOL: ClassVar[int] = ...
    UNKNOWN: ClassVar[int] = ...
    ZERO: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_STAGE:
    EXITPRESOLVE: ClassVar[int] = ...
    EXITSOLVE: ClassVar[int] = ...
    FREE: ClassVar[int] = ...
    FREETRANS: ClassVar[int] = ...
    INIT: ClassVar[int] = ...
    INITPRESOLVE: ClassVar[int] = ...
    INITSOLVE: ClassVar[int] = ...
    PRESOLVED: ClassVar[int] = ...
    PRESOLVING: ClassVar[int] = ...
    PROBLEM: ClassVar[int] = ...
    SOLVED: ClassVar[int] = ...
    SOLVING: ClassVar[int] = ...
    TRANSFORMED: ClassVar[int] = ...
    TRANSFORMING: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PY_SCIP_STATUS:
    BESTSOLLIMIT: ClassVar[int] = ...
    DUALLIMIT: ClassVar[int] = ...
    GAPLIMIT: ClassVar[int] = ...
    INFEASIBLE: ClassVar[int] = ...
    INFORUNBD: ClassVar[int] = ...
    MEMLIMIT: ClassVar[int] = ...
    NODELIMIT: ClassVar[int] = ...
    OPTIMAL: ClassVar[int] = ...
    PRIMALLIMIT: ClassVar[int] = ...
    RESTARTLIMIT: ClassVar[int] = ...
    SOLLIMIT: ClassVar[int] = ...
    STALLNODELIMIT: ClassVar[int] = ...
    TIMELIMIT: ClassVar[int] = ...
    TOTALNODELIMIT: ClassVar[int] = ...
    UNBOUNDED: ClassVar[int] = ...
    UNKNOWN: ClassVar[int] = ...
    USERINTERRUPT: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...

class PowExpr(GenExpr):
    expo: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class Presol:
    model: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def presolexec(self, *args, **kwargs): ...
    def presolexit(self, *args, **kwargs): ...
    def presolexitpre(self, *args, **kwargs): ...
    def presolfree(self, *args, **kwargs): ...
    def presolinit(self, *args, **kwargs): ...
    def presolinitpre(self, *args, **kwargs): ...

class Pricer:
    model: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def pricerexit(self, *args, **kwargs): ...
    def pricerexitsol(self, *args, **kwargs): ...
    def pricerfarkas(self, *args, **kwargs): ...
    def pricerfree(self, *args, **kwargs): ...
    def pricerinit(self, *args, **kwargs): ...
    def pricerinitsol(self, *args, **kwargs): ...
    def pricerredcost(self, *args, **kwargs): ...

class ProdExpr(GenExpr):
    constant: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class Prop:
    model: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def propexec(self, *args, **kwargs): ...
    def propexit(self, *args, **kwargs): ...
    def propexitpre(self, *args, **kwargs): ...
    def propexitsol(self, *args, **kwargs): ...
    def propfree(self, *args, **kwargs): ...
    def propinit(self, *args, **kwargs): ...
    def propinitpre(self, *args, **kwargs): ...
    def propinitsol(self, *args, **kwargs): ...
    def proppresol(self, *args, **kwargs): ...
    def propresprop(self, *args, **kwargs): ...

class Reader:
    model: Incomplete
    name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def readerfree(self, *args, **kwargs): ...
    def readerread(self, *args, **kwargs): ...
    def readerwrite(self, *args, **kwargs): ...

class Relax:
    model: Incomplete
    name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def relaxexec(self, *args, **kwargs): ...
    def relaxexit(self, *args, **kwargs): ...
    def relaxexitsol(self, *args, **kwargs): ...
    def relaxfree(self, *args, **kwargs): ...
    def relaxinit(self, *args, **kwargs): ...
    def relaxinitsol(self, *args, **kwargs): ...

class Row:
    data: Incomplete
    name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def getAge(self, *args, **kwargs): ...
    def getBasisStatus(self, *args, **kwargs): ...
    def getCols(self, *args, **kwargs): ...
    def getConsOriginConshdlrtype(self, *args, **kwargs): ...
    def getConstant(self, *args, **kwargs): ...
    def getDualfarkas(self, *args, **kwargs): ...
    def getDualsol(self, *args, **kwargs): ...
    def getLPPos(self, *args, **kwargs): ...
    def getLhs(self, *args, **kwargs): ...
    def getNLPNonz(self, *args, **kwargs): ...
    def getNNonz(self, *args, **kwargs): ...
    def getNorm(self, *args, **kwargs): ...
    def getOrigintype(self, *args, **kwargs): ...
    def getRhs(self, *args, **kwargs): ...
    def getVals(self, *args, **kwargs): ...
    def isInGlobalCutpool(self, *args, **kwargs): ...
    def isIntegral(self, *args, **kwargs): ...
    def isLocal(self, *args, **kwargs): ...
    def isModifiable(self, *args, **kwargs): ...
    def isRemovable(self, *args, **kwargs): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class RowExact:
    data: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class Sepa:
    model: Incomplete
    name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def sepaexeclp(self, *args, **kwargs): ...
    def sepaexecsol(self, *args, **kwargs): ...
    def sepaexit(self, *args, **kwargs): ...
    def sepaexitsol(self, *args, **kwargs): ...
    def sepafree(self, *args, **kwargs): ...
    def sepainit(self, *args, **kwargs): ...
    def sepainitsol(self, *args, **kwargs): ...

class Solution:
    data: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def _checkStage(self, *args, **kwargs): ...
    def _evaluate(self, *args, **kwargs): ...
    def getOrigin(self, *args, **kwargs): ...
    def retransform(self, *args, **kwargs): ...
    def translate(self, *args, **kwargs): ...
    def __getitem__(self, index): ...
    def __setitem__(self, index, object) -> None: ...

@dataclass
class Statistics:
    status: str
    total_time: float
    solving_time: float
    presolving_time: float
    reading_time: float
    copying_time: float
    problem_name: str
    presolved_problem_name: str
    n_runs: int | None = None
    n_nodes: int | None = None
    n_solutions_found: int = -1
    first_solution: float | None = None
    primal_bound: float | None = None
    dual_bound: float | None = None
    gap: float | None = None
    primal_dual_integral: float | None = None
    @property
    def n_binary_vars(self): ...
    @property
    def n_conss(self): ...
    @property
    def n_continuous_vars(self): ...
    @property
    def n_implicit_integer_vars(self): ...
    @property
    def n_integer_vars(self): ...
    @property
    def n_maximal_cons(self): ...
    @property
    def n_presolved_binary_vars(self): ...
    @property
    def n_presolved_conss(self): ...
    @property
    def n_presolved_continuous_vars(self): ...
    @property
    def n_presolved_implicit_integer_vars(self): ...
    @property
    def n_presolved_integer_vars(self): ...
    @property
    def n_presolved_maximal_cons(self): ...
    @property
    def n_presolved_vars(self): ...
    @property
    def n_vars(self): ...

class SumExpr(GenExpr):
    coefs: Incomplete
    constant: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class Term:
    hashval: Incomplete
    ptrtuple: Incomplete
    vartuple: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def __add__(self, other): ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getitem__(self, index): ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class UnaryExpr(GenExpr):
    def __init__(self, *args, **kwargs) -> None: ...

class VarExpr(GenExpr):
    var: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class Variable(Expr):
    data: Incomplete
    name: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def getAvgSol(self, *args, **kwargs): ...
    def getCol(self, *args, **kwargs): ...
    def getImplType(self, *args, **kwargs): ...
    def getIndex(self, *args, **kwargs): ...
    def getLPSol(self, *args, **kwargs): ...
    def getLbGlobal(self, *args, **kwargs): ...
    def getLbLocal(self, *args, **kwargs): ...
    def getLbOriginal(self, *args, **kwargs): ...
    def getNBranchings(self, *args, **kwargs): ...
    def getNBranchingsCurrentRun(self, *args, **kwargs): ...
    def getNLocksDown(self, *args, **kwargs): ...
    def getNLocksDownType(self, *args, **kwargs): ...
    def getNLocksUp(self, *args, **kwargs): ...
    def getNLocksUpType(self, *args, **kwargs): ...
    def getObj(self, *args, **kwargs): ...
    def getStatus(self, *args, **kwargs): ...
    def getUbGlobal(self, *args, **kwargs): ...
    def getUbLocal(self, *args, **kwargs): ...
    def getUbOriginal(self, *args, **kwargs): ...
    def isActive(self, *args, **kwargs): ...
    def isBinary(self, *args, **kwargs): ...
    def isDeletable(self, *args, **kwargs): ...
    def isImpliedIntegral(self, *args, **kwargs): ...
    def isInLP(self, *args, **kwargs): ...
    def isIntegral(self, *args, **kwargs): ...
    def isNonImpliedIntegral(self, *args, **kwargs): ...
    def isOriginal(self, *args, **kwargs): ...
    def isRelaxationOnly(self, *args, **kwargs): ...
    def markRelaxationOnly(self, *args, **kwargs): ...
    def ptr(self, *args, **kwargs): ...
    def varMayRound(self, *args, **kwargs): ...
    def vtype(self, *args, **kwargs): ...

class _VarArray:
    def __init__(self, *args, **kwargs) -> None: ...
